
Component {
    
    @let offsetX = 150
    @let offsetY = 150
    @let gridW = 8
    // @let gridH = 12
    @let naColor = "#aaa"
    XYPlot {
        static = true
        discreteCategory = true
        x = offsetX + 3; y = 20
        width = gridW * samples.length
        height = offsetY - 23
        data = hist.result
        stackedData = {
            stacked: hist.indexes
        }
        // gap = 1
        padding = 0
        StackedBars {
            data = "stacked" 
            on:click = (ev, el) => debugFunc(ev, el)
            :children(d) {
                Rect.full{
                    fill = hist.colorMap[d.key]
                    // width = 40; x = 50%
                    anchor = @anchor("top","center")
                }
            }
            width = 100%
            height = 100%
            stroke = "#fff"
            fill = "none"
        }
    }
    // Rows {
    //     x = 200; y = 150
    //     @for sp in Object.keys(hist.colorMap) {
    //         Component {
    //             height = 20
    //             Rect {
    //                 width = 15; height = 10; fill = hist.colorMap[sp]
    //             }
    //             Text {
    //                 x = 17; text = sp; fill = "#fff"; fontSize = 10
    //             }
    //         }
    //     }
    // }
    Component {
        x = 20; y = 20; width = 100; height = 100
        Rect.full {
            fill = controllerMode === "zoom" ? "rgb(200,0,0,0.2)" : "rgb(0,200,0,0.2)"
            on:wheel = (ev) => controlMain(ev)
            on:click = swicthMode
        }
        Rect {
            x = 75%; y = 75%; width = 25%; height = 25%
            on:click = fitSize
        }
        
    }
    Component {
        height = fullDisplay ? mainHeight : 300; clip = @clip("bound"); y = offsetY
        Component {
            y = yPos
            // height = gridH * mainHeatmap.length
            height = mainHeight
            Tree { //left side tree
            height = 100%
            static = true
            width = offsetX
            x = 20
            data = ovTree
            direction = "right"
            link.stroke = "#000"
            :leaf({leaf, tree}) {
                Component{}
            }
            :node {
                Component{}
            }
        }

        Component {
            @let height = mainHeight / species.length
            x = offsetX; static = true
            @for (r, i) in mainHeatmap {
                @for (sample, j) in r {
                    Rect {
                        key = `main-${i}-${j}`
                        height = height - 1; width = gridW - 1; x = gridW * j; y = height * i
                        fill = mainColorGetter(sample)
                        on:mouseenter = setActive(gridW * j + offsetX, height * i)
                        on:mouseleave = setActive(null, null)
                        behavior:tooltip {
                            content = `sample: ${samples[j]}<br>species: ${species[i]}<br>relative abundance: ${sample.toExponential(2)}`
                        }
                    }
                }
            }
        }
        //boxplot 
        @if mainHeight/species.length > 10 {
            XYPlot {
            static = true
            x = samples.length * gridW + 10 + offsetX
            invertValueAxis = true
            height = mainHeight
            width = 300
            flip = true
            data = {
                boxData1: boxplot.boxData[0],
                boxData2: boxplot.boxData[1]
            }
            Rect{
                width = 100%
                height = 100%
                fill = "none"
            }
            @for (item, index) in boxplot.boxData{
                Boxes {
                    @let color = index === 0 ? colors.control : colors.gout
                    key = index
                    data = "boxData" + (index + 1).toString()
                    showMean = true
                    showNotch = false
                    y = -gridH/6 + gridH * index /3
                    :box (_d) {
                        Rect.full  {
                            fill = color
                            stroke = color
                            behavior:tooltip {
                                content = (`min: ${_d.data[0].toExponential(2)} <br>
                                            first quartile: ${_d.data[1].toExponential(2)} <br>
                                            median: ${_d.data[2].toExponential(2)} <br>
                                            third quartile: ${_d.data[3].toExponential(2)} <br>
                                            max: ${_d.data[4].toExponential(2)} <br>`)
                            }
                            y = 33%
                            height = 33%
                        }
                    }
                    :whiskle (d) {
                        Line { x2 = 100%; y = 50%; stroke = color;
                        }
                    }
                    :outlier{
                        Circle.centered { r = 2; fill = color }
                    }
                    :mean(means) {
                        Line {y1 = 33%; y2 = 66%; stroke = "#fff"}
                    }
                    :median(d) {}
                }
            }
            Axis("bottom"){
                y = 100%
            }
	    }
        }
        Component {
            @if state.activeX !== null {
                Rect {
                    x = state.activeX; y = 0
                    width = gridW
                    height = mainHeight
                    // stroke = @color("highlight")
                    stroke = "#000"
                    strokeWidth = 2
                    fill = "none"
                    events = "none"
                }
            }
            @if state.activeY !== null {
                Rect {
                    x = offsetX; y = state.activeY
                    width = gridW * samples.length
                    height =  mainHeight / species.length
                    // stroke = @color("highlight")
                    stroke = "#000"
                    strokeWidth = 2
                    fill = "none"
                    events = "none"
                }
                @if mainHeight/species.length > 10{
                    Rect {
                    x = samples.length * gridW + 10 + offsetX; y = state.activeY
                    width = 300
                    height = mainHeight / species.length
                    // stroke = @color("highlight")
                    stroke = "#000"
                    strokeWidth = 2
                    fill = "none"
                    events = "none"
                }
                }
            }
        }
        }
        
    }
    
    
    
    Component { //meta area
        y = offsetY + 10 + (fullDisplay ? mainHeight : 300)
        Text {
            static = true
            anchor = @anchor("t", "c");  y = 2
            x = offsetX + 4 * samples.length; text = "Meta data"
        }

        Component {
            static = true
            y = 20
            //@for (k, i) in Object.keys(m)
            Rows {
                @for (f, i) in metaFeatures {
                    @if !!metaInfo[f] {
                        Component {
                        height = 12
                        Component { // legend area
                            x = 10; height = 100%
                            Columns {
                                Component {
                                    width = 20
                                    Rect {
                                        height = 11; width = 18; fill = naColor
                                    }
                                    Line {
                                        x2 = 20; y1 = 11; stroke = "red" 
                                    }
                                    Text("NA") {
                                        fontSize = 11; anchor = @anchor("t", "c"); x = 10; fill = "#000"
                                    }
                                }
                                @if !metaInfo[f].useNumber {
                                    @let rectW = (offsetX - 10 - 20) / metaInfo[f].values.length 
                                @for (cat, j) in metaInfo[f].values {
                                    Component {
                                        width = rectW
                                        Rect {
                                            height = 11; width = rectW - 2
                                            fill = metaInfo[f].color(cat)
                                        }
                                        @if (rectW > 20) {
                                            Text {
                                                x = 50%; anchor = @anchor("t", "c")
                                                fill = "#000"; text = cat; fontSize = 10
                                            }
                                        }
                                    }
                                }
                                } @else {
                                    Component {
                                    @let div = (metaInfo[f].rangeMax - metaInfo[f].rangeMin) / 20
                                    @let rectW = (offsetX - 10 - 20) / 20
                                    @for i in 20 {
                                        Rect {
                                            height = 11; width = rectW; x = rectW * i
                                            fill = metaInfo[f].color(metaInfo[f].rangeMin + i * div)
                                        }
                                    }
                                    Text(metaInfo[f].rangeMin) {
                                        anchor = @anchor("l", "t"); x = 2; fill = "#000"
                                    }
                                    Text(metaInfo[f].rangeMax) {
                                        anchor = @anchor("right", "top"); x = offsetX - 12 - 20; fill = "#000"
                                    }
                                    }
                                }
                                
                            }
                        }

                        Component {
                            x = offsetX; height = 100%
                        @for (d, j) in metaData[f] {
                            Component {
                                height = 100%; width = 100%
                                on:mouseenter = setActive(gridW * j + offsetX, null)
                                on:mouseleave = setActive(null, null)
                                 behavior:tooltip {
                                    content = `sample: ${samples[j]}<br>${f}: ${d}`
                                }
                                @let metaFill = metaInfo[f].color(d)
                            @if !!metaFill {
                                Rect {
                                    height = 95%; width = gridW - 1; x = gridW * j; fill = metaFill
                                }
                            } @else {
                                Rect {
                                    height = 95%; width = gridW - 1; x = gridW * j; fill = naColor
                                }
                                Line {
                                    x1 = gridW * j; x2 = gridW * j + gridW; y1 = 95%; y2 = 0; stroke = "red"
                                }
                            }
                            }
                            
                            
                        }
                        }
                    }
                    }
                    
                }  
            }
        }

        Component {
            @if state.activeX !== null {
                Rect {
                    //@expr console.log(metaFeatures.length)
                    x = state.activeX; y = 20
                    width = gridW
                    height = 12 * metaFeatures.length
                    // stroke = @color("highlight")
                    stroke = "#000"
                    strokeWidth = 2
                    fill = "none"
                    events = "none"
                }
            }
        }
    }
}