
svg {
	Component {
		DiverBoxPlot{
			y = 20; x = 20
			plotSize = [plotWidth, plotHeight]
			valueRange = valueRange
			// @expr console.log("valueRange",valueRange)
			categories = xTicks.value
			// @expr console.log("tick",xTicks.value)
			discreteCategory = true
			// @expr console.log(boxData)
			// categoryRange = [1, 76]
            data=boxData
			gridW = gridW
			boxW = boxW
			gapRatio=gapRatio
			colors = colors
			drawViolin=false
			drawBox=true
			:boxOutlier(d) {
				Circle.centered {
					r = 2 
					fill = d.fill
					behavior:tooltip {
						content = (`value: ${d.data[1].toFixed(2)}<br>
						time: ${categories[d.data[0]]}`)
					}
				}
			}
		}
			
		DraggableLegend {
			@props legendPos
			title = legendTitle
			data = legendData
			// behavior:drag {
			// 	onDrag = @bind(updateLegendPos)
			// }
			padding = 4
			lineHeight = 13
			legendWidth = 15
			label.fontSize = 10
			:legend(d) {
				Component {
					Line {  x = 50%; y1 = 1; y2 = 12; stroke = lineColor }
					Rect {
						x = 2.5
						y = 2.5
						stroke = lineColor; strokeWidth = 0.8
						height = 8
						width = 10
						fill = d.fill
					}
					Line {  x1 = 3; x2 = 12; y = 6.5; stroke = lineColor }
				}				
			}
		}

	}

}
	
// 	XYPlot {
// 		height = 500
// 		width = plotWidth
// 		padding-y = 20
// 		padding-l = 40
// 		data = {
// 			boxData1: boxData[0],
// 			boxData2: boxData[1]
// 		}
//         categories=categories
// 		valueRange = valueRange
// 		AxisBackground { dashArray = "1, 2" }
// 		// AxisBackground {
// 		// 	orientation = "vertical"
// 		// 	includeEndTicks = true
// 		// 	dashArray = "1, 2"
// 		// }
// 		Rect{
// 			width = 100%
// 			height = 100%
// 			stroke = "#000"
// 			fill = "none"
// 		}
// 		@for (item, index) in boxData{
// 			Boxes {
// 				key = index
// 				data = "boxData" + (index + 1).toString()
// 				showMean = true
// 				showNotch = false
// 				x = -2 + 4 * index
// 				:box (_d) {
// 					Rect.full  {
// 						fill = colors[index]
// 						stroke = colors[index]
// 						fillOpacity = 0.01
// 						behavior:tooltip {
// 							content = (`min: ${_d.data[0].toFixed(2)} <br>
// 										first quartile: ${_d.data[1].toFixed(2)} <br>
// 										median: ${_d.data[2].toFixed(2)} <br>
// 										third quartile: ${_d.data[3].toFixed(2)} <br>
// 										max: ${_d.data[4].toFixed(2)} <br>`)
// 						}
// 						x = 33%
// 						width = 33%
// 					}
// 				}
// 				:whiskle (d) {
// 					Line { x1 = 50%; x2 = 50%; y1 = 0; y2 = 100%; stroke = colors[index];
// 					}
// 				}
// 				:outlier{
// 					@if config.showOutliers {
// 						Circle.centered { r = 2; fill = colors[index] }
// 					} @else {
// 						Circle.centered { fill = "none" }
// 					}
// 				}
// 				:mean(means) {
// 					Line {x1 = 33%; x2 = 66%; stroke = colors[index]}
// 				}
// 				:median(d) {}
// 			}
// 		}
// 		Axis("left");
// 		Line {
// 			x2 = 100%; y = 100%;
// 		}
// 		@for t in xTicks {
// 			Component {
// 				x = t.index * (plotWidth - 40) / (categories.length - 1)
// 				Line {
// 					y1 = 100%; y2 = @geo(100, 3)
// 				}
// 				Text(t.value) {
// 					anchor = @anchor("t", "c"); y = @geo(100,5); fontSize = 10
// 				}
// 			}
			
// 		}
// 		Component {
// 			x = -25; y = 50%
// 			rotation = @rotate(-90)
// 			Text(ylabel) { anchor = @anchor("bottom", "center") }
// 		}
// 		Component{
// 			x = 5%; y = 80%
// 			@for (item, index) in classifications{
// 				Line { key = index; x1 = 7.5; x2 = 7.5; y1 = 24 * index - 10; y2 = 24 * index + 10; stroke = colors[index] }
// 				Line { key = [index, 1]; x1 = 0; x2 = 15; y1 = 24 * index; y2 = 24 * index; stroke = colors[index] }
// 				Rect {
// 					key = index
// 					x = 0
// 					y = index * 24
// 					height = 10
// 					width = 15
// 					anchor = @anchor("middle","left")
// 					fill = "none"
// 					stroke = colors[index]
// 				}
// 				Text{
// 					x = 20
// 					y = index * 24
// 					key = index
// 					anchor = @anchor("middle","left")
// 					text = item
// 					fontSize = 12
// 				}
// 			}
// 		}
// 	}
// }