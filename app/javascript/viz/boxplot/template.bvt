svg {
    height = 700; width = 1000
    XYPlot {
		height = 700; width = 700
		padding = 80
		data = {boxData}
        valueRange = boxData.valueRange

		Rect.full {
			stroke = @color("line"); fill = "none"
		}
        Boxes {
            data = "boxData"
            showMean = true
            showNotch = false
            @let boxColors = getBoxColors(colors.default)
            :box (_d) {
                Rect.full  {
                    fill = boxColors[1]
                    stroke = boxColors[0]
                    behavior:tooltip {
                        content = (`min: ${_d.data[0].toFixed(2)} <br>
                                    first quartile: ${_d.data[1].toFixed(2)} <br>
                                    median: ${_d.data[2].toFixed(2)} <br>
                                    third quartile: ${_d.data[3].toFixed(2)} <br>
                                    max: ${_d.data[4].toFixed(2)} <br>`)
                    }
                    x = 20%
                    width = 60%
                }
            }
            :whiskle (d) {
                Component {
                    height = 100%
                    Line { 
                        x = 50%; y2 = 100%
                        stroke = boxColors[0]
                    }
                }
                
            }
            :outlier{
                @if config.showOutliers {
                    Circle.centered { 
                        r = 2
                        stroke = boxColors[0]; fill = boxColors[1] 
                    }
                } @else {
                    Circle.centered { fill = "none" }
                }
            }
            :mean(means) {
                Line {x1 = 20%; x2 = 80%; stroke = boxColors[2] }
            }
            :median {}
        }
		@let w = @scaled-x(1) - @scaled-x(0)
        @if config.showP {
            @for pair in pDict[ranks[config.rankIndex].text] {
                Component {
                    @let sourceIndex = boxData.categories.indexOf(pair.source)
                    @let targetIndex = boxData.categories.indexOf(pair.target)
                    @let sourceX = @scaled-x(sourceIndex) + (sourceIndex === 1 ? 5 : 0)
                    @let targetX =  @scaled-x(targetIndex) + (targetIndex === 1 ? -5 : 0)
                    y = @scaled-y(boxData.max)+ (Math.abs(sourceIndex - targetIndex) > 1 ? -40: -20)
                    Line {
                        x = sourceX; y2 = 10
                    }
                    Line {
                        x = targetX; y2 = 10
                    }
                    Line {
                        x1 = sourceX; x2 = targetX;
                    }
                    Text {
                        x = (targetX + sourceX)/2; y = -2; anchor = @anchor("c", "b")
                        text = pair.pValue < 0.001 ? "p < 0.001" : `p = ${pair.pValue.toFixed(3)}`
                    }
                }
            }
        }

		Axis("left");
		Axis("bottom") {
			y = 100%
			:label (tick) {
				Text {
					text = tick.value + "  "
					rotation = @rotate(-config.xLabelRotation)
					anchor = @anchor("r", "m")
					fontSize = 13
				}
			}
		}
		Component {
			x = -25; y = 50%
			rotation = @rotate(-90)
			Text(ylabel) { anchor = @anchor("bottom", "center") }
		}
	}
}