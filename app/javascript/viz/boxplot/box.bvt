GridPlot {
    @props prop
    :content {
        @if prop.drawBox{        
        Boxes {
            static = true
            data = "boxData"
            showMean = true
            showNotch = false
            :box (_d) {
                Rect.full  {
                    @let boxColors = getBoxColors(prop.getColor(_d.pos))
                    fill = boxColors[1]
                    stroke = boxColors[0]
                    // fillOpacity = 0.001
                    behavior:tooltip {
                        content = (`min: ${_d.data[0].toFixed(2)} <br>
                                    first quartile: ${_d.data[1].toFixed(2)} <br>
                                    median: ${_d.data[2].toFixed(2)} <br>
                                    third quartile: ${_d.data[3].toFixed(2)} <br>
                                    max: ${_d.data[4].toFixed(2)} <br>`)
                    }
                    x = 20%
                    width = 60%
                }
            }
            :whiskle (d) {
                Component {
                    @let boxColors = getBoxColors(prop.getColor(d.pos))
                    height = 100%
                    Line { 
                        x = 50%; y2 = 100%
                        stroke = boxColors[0]; strokeWidth = 2
                    }
                }
                
            }
            :outlier(d){
                Circle.centered {
                    @let boxColors = getBoxColors(prop.getColor(d[0]))
                    r = 2; fill = boxColors[0]; visible = prop.showOutliers
                }
            }
            :mean(d) {
                Line {
                    @let boxColors = getBoxColors(prop.getColor(d.pos))
                    x1 = 20%; x2 = 80%; stroke = boxColors[2]; strokeWidth = 2
                }
            }
            :median {}
        }
        }
        @if prop.drawViolin {
            Violins {
                static = true
                data = "violinData"
                dataLine = false
                quartile = false
                extremeLine = false
                basisCurve = true
            }
        }
        @if prop.drawScatter {
            Scatters1D {
                static = true
                data = "scatterData"
                :children(d) {
                    Circle.centered {
                        r = 2
                        fill = prop.getScatterColor(d.pos)
                    }
                }
            }
        }
        @if prop.pData && prop.drawP {
        Component { 
            y = @scaled-y(boxMax)  + offsetY
            behavior:drag {
                direction = "y"
                onDrag = @bind(dragP)
            }
             @for pair in prop.pData {
                Container {
                
                    @let sourceX = @scaled-x(pair.sourcePos) + (pair.sourcePos === 1 ? 5 : 0)
                    @let targetX =  @scaled-x(pair.targetPos) + (pair.targetPos === 1 ? -5 : 0)
                    y = ((pair.targetPos - pair.sourcePos) > 1 ? -40: -20)
                    Line {
                        x = sourceX; y2 = 10
                    }
                    Line {
                        x = targetX; y2 = 10
                    }
                    Line {
                        x1 = sourceX; x2 = targetX;
                    }
                    Text {
                        x = (targetX + sourceX)/2; y = -2; anchor = @anchor("c", "b")
                        text = pair.pValue < 0.001 ? "p < 0.001" : `p = ${pair.pValue.toFixed(3)}`
                    }
                }
            }
        }
        }
    }
}